A (very short) introduction to Python
======================================


.. topic:: Python for scientific computing

    We introduce here the Python language. Only the bare minimum
    necessary for getting started with Numpy and Scipy is addressed here.
    To learn more about the language, consider going through the
    excellent tutorial http://docs.python.org/tutorial. Dedicated books
    are also available, such as http://diveintopython.org/.


What is Python?
----------------------

.. image:: python-logo.png
   :align: right

Python is a **programming language**, as are C, Fortran, BASIC, PHP,
etc. Some specific features of Python are as follows:

* an *interpreted* (as opposed to *compiled*) language. Contrary to e.g.
  C or Fortran, one does not compile Python code before executing it. In
  addition, Python can be used **interactively**: many Python
  interpreters are available, from which commands and scripts can be
  executed.

* a free software released under an **open-source** license: Python can
  be used and distributed free of charge, even for building commercial
  software.

* **multi-platform**: Python is available for all major operating
  systems, Windows, Linu/Unix, MacOS X, most likely your mobile phone OS,
  etc.

* a very readable language with clear non-verbose syntax

* a language for which a large variety of high-quality packages are
  available for various applications, from web frameworks to scientific
  computing.

* a language very easy to interface with other languages, in particular C
  and C++.

* Some other features of the language are illustrated just below. For
  example, Python is an object-oriented language, with dynamic typing
  (an object's type can change during the course of a program).


See http://www.python.org/about/ for more information about
distinguishing features of Python. 

Premiers pas
---------------

Start the **Ipython** shell (an enhanced interactive Python shell) by

* type "Ipython" from a Linux/Mac terminal, or from the Windows cmd shell,
* **or** by starting the program from a menu, e.g. in the Python(x,y) or
  EPD menu if you have installed one these scientific-Python suites.

If you don't have Ipython installed on your computer, other Python shells
are available, such as the plain Python shell started by typing "python"
in a terminal, or the Idle interpreter. However, we advise to use the
Ipython shell because of its enhanced features, especially for
interactive scientific computing.

Once you have started the interpreter, type ::

    >>> print "Hello, world!"
    Hello, world!

The message "Hello, world!" is then displayed. You just executed your
first Python instruction, congratulations!

To get yourself started, type the following stack of instructions ::

    >>> a = 3
    >>> b = 2*a
    >>> type(b)
    <type 'int'>
    >>> print b
    6
    >>> a*b 
    18
    >>> b = 'hello' 
    >>> type(b)
    <type 'str'>
    >>> b + b
    'hellohello'
    >>> 2*b
    'hellohello'

Two objects ``a`` and ``b`` have been defined above. Note that one does
not declare the type of an object before assigning its value. In C,
conversely, one should write:

.. sourcecode:: c

    int a;
    a = 3;

In addition, the type of an object may change. `b` was first an integer,
but it became a string when it was assigned the value `hello`. Operations
on integers (``b=2*a``) are coded natively in the Python standard
library, and so are some operations on strings such as additions and
multiplications, which amount respectively to concatenation and
repetition. 

.. topic:: A bag of Ipython tricks

    * Several Linux shell commands work in Ipython, such as ls, pwd,
      cd, etc.

    * To get help about objects, functions, etc., type ``help object``.
      Just type help() to get started.

    * Use **tab-completion** as much as possible: while typing the
      beginning of an object's name (variable, function, module), press 
      the **Tab** key and Ipython will complete the expression to match 
      available names. If many names are possible, a list of names is 
      displayed.

    * **History**: press the up (resp. down) arrow to go through all
      previous (resp. next) instructions starting with the expression on
      the left of the cursor (put the cursor at the beginning of the line
      to go through all previous commands) 

    * You may log your session by using the Ipython "magic command"
      %logstart. Your instructions will be saved in a file, that you can
      execute as a script in a different session.


.. sourcecode:: ipython

    In [1]: %logstart commandes.log
    Activating auto-logging. Current session state plus future input saved.
    Filename       : commandes.log
    Mode           : backup
    Output logging : False
    Raw input log  : False
    Timestamping   : False
    State          : active
 

Different objects
-------------------

**Numerical types**

We have created above integer variables (``int``). There exist also
floats ::

    >>> c = 2.1

and booleans::

    >>> c > a
    False
    >>> test = (c > a)
    >>> test
    False
    >>> type(test)
    <type 'bool'>

Complex numbers are a native type in Python ::

    >>> a=1.5+0.5j
    >>> a.real
    1.5
    >>> a.imag
    0.5

A Python shell can therefore replace your pocket calculator, with the
basic arithmetic operations +, -, \*, /, % (modulo) natively implemented::

    >>> 7 * 3.
    21.0
    >>> a = 8
    >>> b = 3
    >>> a/b # Integer division corresponds to Euclidean division
    2
    >>> float(a)/b # float() transforms a number (here an int) into a
    >>> # float
    2.6666666666666665
    >>> a%3
    2

**Strings** 

Strings are delimited by simple or double quotes::

    >>> "hello"
    'hello'
    >>> 'hello'
    'hello'
    >>> "what's up?"
    "what's up?"

.. sourcecode:: ipython

    In [9]: 'what's up'
    ------------------------------------------------------------
       File "<ipython console>", line 1
	 'what's up'
               ^
    SyntaxError: invalid syntax


As seen abobe, strings are concatenated with + and repeated with * ::

    >>> "how " + "are" + " you?" 
    'how are you?'
    >>> 2*"hello "
    'hello hello '

The newline character is ``\n``, and the tab characted is
``\t``.

The n*th* character of a string ``s`` is ``s[n]``::

    >>> a = "hello"
    >>> a[0]
    'h'
    >>> a[1]
    'e'
    >>> a[-1]
    'o'

Careful: **the first character of a string has index 0** (like in C), not
1 (like in Fortran or Matlab)! 

Negative indices correspond to counting from the right end.

It is also possible to define a substring of regularly spaced characters,
called a **slice**
::

    >>> a = "hello, world!"
    >>> a[3:6] # 3rd to 6th (excluded) elements: elements 3, 4, 5
    'lo,'
    >>> # the a[start:stop] slice has (strop - start) elements
    >>> a[2:10:2] # Syntax: a[start:stop:step]
    'lo o'
    >>> a[::3] # every three characters, from beginning to end 
    'hl r!'
    >>> a[:10] # the ten first characters
    'hello, wor'
    >>> a[::-1] # running backwards
    '!dlrow ,olleh'

Accents and special characters can also be handled in Unicode strigs (see
http://docs.python.org/tutorial/introduction.html#unicode-strings).


A string is an immutable objects and it is not possible to modify its
characters. One may however create new strings from an orginal one.

.. sourcecode:: ipython

    In [53]: a = "hello, world!"
    In [54]: a[2] = 'z'
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call
    last)

    /home/gouillar/travail/sgr/2009/talks/dakar_python/cours/gael/essai/source/<ipython
    console> in <module>()

    TypeError: 'str' object does not support item assignment
    In [55]: a.replace('l', 'z', 1)
    Out[55]: 'hezlo, world!'
    In [56]: a.replace('l', 'z')
    Out[56]: 'hezzo, worzd!'

.. warning:: 

    Python offers advanced possibilities for manipulating strings,
    looking for patterns or formatting. Due to lack of time this topic is
    not addressed here, but the interested reader is referred to
    http://docs.python.org/library/stdtypes.html#string-methods et
    http://docs.python.org/library/string.html#new-string-formatting

**Lists**

.. put lists before strings? And add blurb about lists vs arrays.

A list is an ordered collection of objects, that may have different
types. For example ::

    >>> l = [3, 2, 'hello']
    >>> l
    [3, 2, 'hello']

The elements of a list are accessed by **indexing** the list as for strings.
Also, sub-lists are obtained by **slicing** ::

    >>> l[0]
    3
    >>> l[-1]
    'bonjour'
    >>> l[1:]
    [2, 'hello']
    >>> l[::2]
    [3, 'hello']

Unlike strings, a list is mutable and its elements can be modified ::

    >>> l[0] = 1
    >>> l
    [1, 2, 'hello']

As for strings, Python offers a large panel of functions to modify lists,
or query them. Here are a few examples; for more details, see
http://docs.python.org/tutorial/datastructures.html#more-on-lists ::

    >>> a = [66.25, 333, 333, 1, 1234.5]
    >>> print a.count(333), a.count(66.25), a.count('x')
    2 1 0
    >>> a.insert(2, -1)
    >>> a.append(333)
    >>> a
    [66.25, 333, -1, 333, 1, 1234.5, 333]
    >>> a.index(333)
    1
    >>> a.remove(333)
    >>> a
    [66.25, -1, 333, 1, 1234.5, 333]
    >>> a.reverse()
    >>> a
    [333, 1234.5, 1, 333, -1, 66.25]
    >>> a.sort()
    >>> a
    [-1, 1, 66.25, 333, 333, 1234.5]

The notation ``a.function()`` is our first example of object-oriented
programming (OOP). Being a ``list``, the object `a` owns the *method*
`function` that is called using the notation **.**. No further knowledge
of OOP than understanding the notation **.** is necessary for going
through this tutorial.  

**Tuples**

Tuples are basically immutable lists. 

En gros, les tuples sont des listes immutables. The elements of a tuple
are written between brackets, or just separated by commas ::


    >>> t = 12345, 54321, 'hello!'
    >>> t[0]
    12345
    >>> t
    (12345, 54321, 'hello!')
    >>> u = (0, 2)

**Dictionnaries**

A dictionnary is basically a hash table that **maps keys to values**. It
is therefore an unordered container. ::


    >>> tel = {'emmanuelle': 5752, 'sebastian': 5578}
    >>> tel['francis'] = 5915 
    >>> tel
    {'sebastian': 5578, 'francis': 5915, 'emmanuelle': 5752}
    >>> tel['sebastian']
    5578
    >>> tel.keys()
    ['sebastian', 'francis', 'emmanuelle']
    >>> 'francis' in tel
    True

This is a very convenient data container in order to store values
associated to a name (a string for a date, a name, etc.). See
http://docs.python.org/tutorial/datastructures.html#dictionaries
for more information.

Flow control
--------------------

**Defining functions**

We now define a function that computes the ``n`` first terms of Fibonacci
sequence. Now type the following line in your Python interpreter, and be
careful to **respect the identation depth**. The Ipython shells automatically
increases the indentation depth after a **:** sign; for decreasing the
identation depth go four spaces to the left with the Backspace or left arrow
keys. Press the Enter key twice for leaving the function definition. ::

    >>> def fib(n):    
    ...     """Display the n first terms of Fibonacci sequence"""
    ...     a, b = 0, 1
    ...     i = 0
    ...     while i < n:
    ...         print b
    ...         a, b = b, a+b
    ...         i +=1
    ...
    >>> fib(10)
    1
    1 
    2
    3
    5
    8
    13
    21
    34
    55
 

Another example ::

    >>> def message(name, country='France'):
    ...     message = "Hello, my name is %s and I live in %s."%(name, country)
    ...     return message # the output of the function
    ... 
    >>> message('Emma')
    'Hello, my name is Emma and I live in France.'
    >>> message('Mike', country='Germany')
    'Hello, my name is Mike and I live in Germany.'
    >>> message('Mike', 'Germany')
    'Hello, my name is Mike and I live in Germany.'


Note the syntax to define a function:

    * the ``def`` keyword;
    
    * is followed by the function's **name**, then

    * the arguments of the function are given between brackets followed
      by a colon. 

    * the function body ;

    * in order to finally return an object as output, use the syntax
      ``return object``.

Note that it is possible to define **optional arguments**, the default
value of which is set in the defintion of the function. These arguments
are known as **keyword arguments**. This is a very convenient feature for
defining functions with a variable number of arguments, especially when
default values are to be used in most calls to the function.

.. warning:: 

    Indenting is compulsory in Python. Every commands block following a
    colon bears an additional indentation level with respect to the
    previous line with a colon. One must therefore indent after 
    ``def f():`` or ``while:``. At the end of such a logical blocks, one
    decreases the indentation depth (and re-increases it if a new block is
    entered, etc.)

    Strict respect of indentation is the price to pay for getting rid of
    ``{`` or ``;`` characters that delineate logical blocks in other
    languages. Improper identation leads to errors such as

    .. sourcecode:: ipython

	------------------------------------------------------------
	IndentationError: unexpected indent (test.py, line 2)

    In particular, one should not start a newline if the middle of an
    instruction. Long lines can nevertheless be broken with ``\``::
   
	>>> long_line = "Here is a very very long line \
	... that we break in two parts."
 
    All this indentation business can be a bit confusing in the
    beginning. However, with the clear identation,  and in the absence of
    extra characters, the resulting code is very nice to read compared to
    other languages.


As in most languages, one can write ``for``and ``while`` loops, or test
conditions with ``if`` and ``else`` ::

    >>> # range(start, stop, step) returns a list of integers
    >>> l = range(0, 10) 
    >>> l     
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> for number in l:
    ...     if (number%2 == 0):
    ...         print number
    ...     else:
    ...         print "odd number"
    ...         
    0
    odd number
    2
    odd number
    4
    odd number
    6
    odd number
    8
    odd number


On peut boucler sur autre chose que des indices entiers : Python peut par
exemple itérer sur les éléments d'une liste, les caractères d'une chaîne
de caractères, etc. ::

    >>> message = "hello"
    >>> for c in message:
    ...     print c
    ...     
    h
    e
    l
    l
    o
    >>> message = "Hello how are you?"
    >>> message.split()
    ['Hello', 'how', 'are', 'you?']
    >>> for word in message.split():
    ...     print word
    ...     
    Hello
    how
    are
    you?
    >>> l = [[1, 2, 3], 'hello', [5, 6]]
    >>> for element in l:
    ...     print element
    ...     
    [1, 2, 3]
    hello
    [5, 6]


Few languages (in particular, languages for scienfic computing) allow to
loop over anything but integers/indices. With Python it is possible to
loop exactly over the objects of interest without bothering with indices
you often don't care about.


Scripts and modules
---------------------

Pour le moment nous avons tapé toutes nos instructions dans
l'interpréteur. Bien sûr, il faut changer de méthode pour écrire des
programmes plus longs ! On va alors écrire notre code dans des fichiers à
l'aide d'un éditeur de texte (votre éditeur préféré, ou celui fourni par
votre distribution de Python si vous utilisez Python à l'intérieur d'une
suite de calcul scientifique comme EPD ou Python(x,y)). 

Commençons par écrire un **script**, c'est-à-dire un fichier contenant
une simple série d'instructions, qu'on peut par exemple copier-coller à
partir de l'interpréteur (mais en respectant l'indentation !!).
L'extension d'un fichier avec du code python est **.py**. Copier-coller
dans un fichier **test.py** les lignes suivantes ::

    message = "Hello how are you?"
    for word in message.split():
        print word

Pour exécuter ce petit script, on peut :

    * l'exécuter dans une console (console linux/Mac ou console cmd
      Windows). Par exemple, si on est dans le même répertoire que le
      fichier test.py, on peut exécuter dans une console

.. sourcecode:: bash 

    epsilon:~/sandbox$ python test.py
    Hello
    how
    are
    you?

Cependant, il ne s'agit pas d'une utilisation interactive, et dans
le cadre du calcul scientifique, on travail (le plus) souvent en mode
interactif, c'est-à-dire à l'intérieur d'un interpréteur :

    * dans Ipython, la syntaxe pour exécuter un script est ``%run
      script.py`` (ne pas oublier le ``%`` devant ``run`` !). Par
      exemple, 

.. sourcecode:: ipython

    In [1]: %run test.py
    Hello
    how
    are
    you?

    In [2]: message
    Out[2]: 'Hello how are you?'

    
Le script s'est exécuté, qui plus est les variables définies dans le
script sont maintenant accessibles (comme ``message``).

Si on veut écrire des programmes un peu plus longs et plus organisés, où
on définit des objets (variables, fonctions, classes) que l'on
souhaiterait pouvoir réutiliser plusieurs fois, on définit un **module**.
Voici un exemple de module contenu dans le fichier suites.py (recopier le
contenu dans un fichier appelé suites.py) ::

    def fib(n):
        "return nth term of Fibonacci sequence"
        a, b = 0, 1
        i = 0
        while i<n:
            a, b = b, a+b
            i += 1
        return b
    
    def linear_recurrence(n, (a,b)=(2,0), (u0, u1)=(1,1)):
        """return nth term of the sequence defined by the
        linear recurrence
            u(n+2) = a*u(n+1) + b*u(n)"""
        i = 0
        u, v = u0, u1
        while i<n:
            w = a*v + b*u
            u, v = v, w
            i +=1
        return w
 
Dans ce fichier, on a défini deux types de suite. Supposons maintenant
qu'on veuille appeler la fonction ``fib`` à partir de l'interpréteur. On
pourrait exécuter le module comme un script, mais puiqu'il n'y a pas
d'instructions à exécuter à l'intérieur, nous allons plutôt l'**importer
en tant que module**. La syntaxe est la suivante :: 

    >>> import suites
    >>> suites.linear_recurrence(10)
    1024
    >>> for i in range(5):
    ...     print i, suites.fib(i)
    ...     
    0 1
    1 1
    2 2
    3 3
    4 5

Le code du fichier n'est pas exécuté lors de l'import du module. Par
contre, on peut se servir des objets qu'il définit grâce à la syntaxe
``module.objet``. Il ne faut pas oublier de rajouter le nom du module
devant le nom de l'objet, sinon Python ne reconnaît pas l'instruction. 

Si on veut éviter de taper à chaque fois ``module.objet``, on peut
importer certains ou tous les objets du module dans l'"espace de nommage"
principal (main namespace en anglais). Par exemple ::

    >>>from suites import fib
    >>> fib(10)
    89
    >>> # ou
    >>> from suites import *
    >>> linear_recurrence(5)
    32


.. sourcecode:: ipython

    In [29]: who
    fib linear_recurrence	

    In [30]: whos
    Variable            Type        Data/Info
    -----------------------------------------
    fib                 function    <function fib at 0x96eb8ec>
    linear_recurrence   function    <function linear_recurrence at 0x96eb9cc>


Quand on utilise ``from module import *``, il faut faire attention à ne
pas écraser un objet déjà existant (par exemple, si on avait déjà une
fonction ou une variable appelée ``fib``). Il faut donc éviter cet usage
pour les modules avec beaucoup d'objets, ou quand on a des noms d'objets
courants (max, mean, etc.). 




Pour raccourcir les noms qu'on tape, on peut importer un module sous un
nom plus court. Par exemple, c'est une convention très classique
d'importer le module ``numpy`` (tableaux de données, que nous allons étudier
par le suite) sous le nom ``np`` ::

    >>> import numpy as np
    >>> type(np)
    <type 'module'>

On peut définir des
sous-modules à l'intérieur d'un module ::

    >>> import scipy # routines de calcul scientifique
    >>> import scipy.optimize # sous-module d'optimisation
    >>> type(scipy.optimize)
    <type 'module'>
    >>> import scipy.optimize as opti # plus court !


Les modules sont donc un moyen d'organiser un code de façon hiérarchique. En fait, tous les
packages
d'informatique scientifique que nous allons utiliser avec Python seront 
des modules ::

    >>> import numpy as np # tableaux de donnees
    >>> np.linspace(0, 10, 6)
    array([  0.,   2.,   4.,   6.,   8.,  10.])
    >>> import scipy # calcul scientifique
    >>> from pylab import * # plot de donnees 
    >>> # appeler Ipython avec le switch -pylab est equivalent
    >>> # à la ligne precedente (ipython -pylab)

Et comme on l'a déjà vu, quand on écrit un fichier de code organisé (ex :
``suites.py``,  on crée un module.

Dans le logiciel Python(x,y), Ipython(x,y) exécute au démarrage les
imports suivants::

    >>> import numpy	
    >>> import numpy as np
    >>> from pylab import *
    >>> import scipy

et il n'est donc pas nécessaire de refaire ces imports.



Input et Output
----------------

Par souci d'exhaustivité, voici quelques informations sur l'input et
l'output dans Python. Néanmoins, nous nous servirons des méthodes de
Numpy pour lire et écrire dans des fichiers, on peut donc sauter ce
paragraphe en première lecture.

On écrit et on lit des **strings** dans les fichiers (il faut convertir
les autres types en strings). Pour écrire dans un fichier 
::

    >>> f = open('workfile', 'w') # ouvre le fichier workfile
    >>> type(f)
    <type 'file'>
    >>> f.write('Ceci est un test \nEncore un test')
    >>> f.close()

Pour lire dans un fichier ::

    >>> f = open('workfile', 'r')
    >>> s = f.read()
    >>> print s
    Ceci est un test 
    Encore un test
    >>> f.close()

Pour plus de détails : http://docs.python.org/tutorial/inputoutput.html

Erreurs et exceptions
------------------------

Si vous avez essayé d'exécuter tous les exemples précédents, il serait
bien étonnant que vous n'ayez pas rencontré une erreur à un moment... :-? 

Vous avez alors peut-être remarqué qu'il y a plusieurs types d'erreurs :
``SyntaxError, ImportError, ValueError``, accompagnée chacune d'un
message d'erreur. Le nom de l'erreur comme le message d'erreur
renseignent sur l'origine de l'erreur et aident donc au débuggage.
Chaque utilisateur peut également prévoir des cas où son code va
retourner une erreur (par exemple si un paramètre d'entrée n'a pas le
type attendu). 

Pour bien profiter de la richesse de Python, il faut donc se servir des
erreurs, par exemple pour prévoir des cas où les utilisateurs font appel
à une fonction pour une utilisation non prévue. Nous laissons
le lecteur se référer à http://docs.python.org/tutorial/errors.html pour
plus de détails sur la gestion des erreurs et des exceptions.

Programmation orientée objet
----------------------------- 

La programmation orientée objet a pour but de 

    * hiérarchiser/organiser du code

    * favoriser la réutilisation de code pour ne pas recopier le même
      bout de code à différents endroits dans des contextes proches mais
      différents.

En voici un petit exemple : on va créer une **classe** Etudiant,
c'est-à-dire un objet regroupant un certain nombre de fonction (des
**méthodes**) et de variables (des **attributs**) qui lui sont propre, et
qu'on pourra appeler ::

    >>> class Etudiant(object):
    ...     def __init__(self, name):
    ...         self.name = name
    ...     def set_age(self, age):
    ...         self.age = age
    ...     def set_major(self, major):
    ...         self.major = major
    ...         
    >>> anne = Etudiant('anne')
    >>> anne.set_age(21)
    >>> anne.set_major('physique')

Dans l'exemple précédent, la classe Etudiant a comme méthode ``__init__,
set_age`` et ``set_major``. Ses attributs sont ``name, age`` et
``major``. On appelle les méthodes et les attributs avec la notation
``InstanceDeLaClasse.methode`` ou  ``InstanceDeLaClasse.attribut``. Le
constructeur ``__init__`` est une méthode à part, qu'on appelle sous la
forme ``InstanceDeLaClasse(paramètres de __init__ s'il y en a)``.

Supposons maintenant qu'on veuille créer une nouvelle classe
EtudiantMaster avec les
mêmes méthodes et attributs que la précédente, mais avec un attribut
``stage`` supplémentaire. On ne va pas réécrire toute la classe
précédente, mais **hériter** de la classe Etudiant :: 

    >>> class EtudiantMaster(Etudiant):
    ...     stage = 'obligatoire, de mars a juin'
    ...     
    >>> benoit = EtudiantMaster('benoit')
    >>> benoit.stage
    'obligatoire, de mars a juin'
    >>> benoit.set_age(23)
    >>> benoit.age
    23

La classe EtudiantMaster a **hérité** des méthodes et attributs de la
classe Etudiant. 

Grâce aux classes et à la programmation orientée objet, on peut donc
organiser son code avec différentes classes correspondant à différents
objets qu'on rencontre (une classe Manip, une class Image, une classe
Ecoulement, etc.), avec leurs méthodes et leurs attributs. On peut alors
se servir de l'héritage pour considérer des variations autour d'une
classe de base, et **mutualiser** ainsi du code. Ex : d'une classe de
base turbulent, on peut faire hériter une sous-classe EcoulementStokes,
EcoulementNewtonien, EcoulementPotentiel, etc.



